// Single Number


// Single Number II

一个整数序列，每个数字都出现三次只有一个数字出现了一次(也可以出现一次或两次)，找到这个数字

利用上面异或的思想，找到某种运算使得三次计算结果后为0，一次和两次的计算结果和数字本身相同，本质上还是采用bitmap的思想

采用两个整数变量a和b，如果a的某一位是1，代表目前为止这一位出现了1次，如果b的某一位是1，代表到目前为止这一位出现了2次，a和b对应位置上都为0表示这一位出现了0次或3次(因为需要保证三次运算结果为0)

```
a' = ((~a) & (~b) & c) | (a & (~b) & (~c));
b' = (a & (~b) & c) | ((~a) & b & (~c));
```

// Single Number III

一个整数序列，每个数字都出现了两次只有两个数字出现了一次，找到这两个数字

两个出现一次的数字不能简单的使用异或找到，但是考虑一下，假设a, b分别是这两个只出现一次的数字，c1, c2, …, cn代表其他的数字，那么

a, c1, c2, …, cn这个序列可以采用问题一的解法求得a(异或一遍)

b, c1, c2, …, cn这个序列同样可以采用问题一的解法

但是要怎样分离出a和b呢，如果最开始异或一遍整数序列，那么得到的结果就是a ^ b的值，由于a和b肯定不相等，那么a ^ b != 0，这就会导致结果中肯定有一位是1，哪一位都可以，不过最好找的是最右边的1，即

```
int diff = a ^ b;
diff = (diff) & (~(diff - 1));
```

此时diff只有一位是1，且这一位的1是整个diff中最右边的1。那么就可以采用这个diff区分a和b，因为a和b一定有一个该位是1，有一个该位是0，才可以在异或结果中使得该位是1






