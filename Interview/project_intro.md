https://mp.weixin.qq.com/s/ZALPGbsvYpKv66POZ4V6dw

- 如何设计排行榜
  - Requirement
    - 个人总得分和总排名实时更新；
    - 个人排行榜按分数、时间、次数、正确率展示；
    - 日榜、过去N日榜滚动更新；
  - 性能优化过程
    - 谷歌开源的JamsRanking
    - 优点是可以直接使用现成的setScores和getRanking接口封装了Redis和Mysql和消息队列的完成事务和一致性的使用细节。缺点是并发比较低使用Jmeter进行压测，单机只有20左右的TPS。
    - 可以采用批量合并事务的方式进行优化。基于这个思路，我们把写操作进行了封装并放入了队列，然后在消费者端批量取得数据后进行事务的批量处理，压测环境下整体性能达到了500TPS
    - 提前配置队列的数量、负载策略和最大容量等信息，保证所有队列不同时触发再分片。
    - 方案1：每日一个滚动榜，当日汇聚（费时间）
      - 首先记录每天的排行榜和一个滚动榜，加分时同时写入这两个榜单，每日零点后跑工具将前几天数据累加写入当日滚动榜，该方案缺点是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受。
    - 方案2：全局N个滚动榜同时写（费空间）
      - 要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。可以写当天的滚动榜的同时，写往后N-1天的滚动榜一起写入该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，但是对于百日榜，空间消耗无法接受，1000万榜单大约消耗1G内存。
    - 方案3：实时更新，常数次写操作
      - 记录每天的排行榜和一个滚动榜，加分操作也还是同时操作当日榜和全局榜，但每日零点的离线作业改为从全局榜中减去之前过期的数据，从而实现先滚动更新。 此方案每次只需读取一个日榜做减法，时间复杂度为O(1)；但是无法做到实时更新。 这个方案的优点是在十二点前提前准备好差分榜，到了十二点直接加上当天数据就是滚动榜内容 ，这样就在常数次写操作的前提下，实现了滚动榜的实时更新。
    - 如何解决重复答题  利用setnx防止重复答题
    - 一个题目被多个人抢答
     - 利用redis来实现乐观锁（抢答），好处是答错的人不影响状态，第一个秒杀答对的人才能得分。
       - 1、利用redis的watch功能，监控这个 Corp:Activ:Qust: 的状态值；
       - 2、获取Corp:Activ:Qust: 的值，创建redis事务，给这个key的值-1；
       - 3、执行这个事务，如果key的值被修改过则回滚，key不变；
    - 如何管理昵称重复  使用布隆过滤器
    - 如何管理出题定时任务  TimeWheel

- 秒杀系统设计
  - 要尽力将请求拦截在系统上游，层层设阻拦截，过滤掉无效或超量的请求
  - 要充分利用缓存，提升系统的性能和可用性
  - 如何解决超卖？
    - mysql乐观锁+redis预减库存+redis缓存卖完标记 
      - 第一是基于数据库乐观锁的方式保证数据并发扣减的强一致性；
      - 第二是基于数据库的事务实现批量扣减部分失败时的数据回滚。
      - 在扣减指定数量前应先做一次前置数量校验的读请求
  - 如何解决重复下单？mysql唯一索引+分布式锁 
  - 如何防刷？IP限流 | 验证码 | 单用户 | 单设备 | IMEI | 源IP |均设置规则
  - 热key问题如何解决？redis集群+本地缓存+限流+key加随机值分布在多个实例中
  - 应对高并发的写请求
    - 削峰：恶意用户拦截
      - 对于单用户多次点击、单设备、IMEI、源IP均设置规则；
      - 采用比较成熟的漏桶算法、令牌桶算法，也可以使用guava开箱即用的限流算法；
        - 可以集群限流，但单机限流更加简洁和稳定；
    - 当前层直接过滤一定比例的请求，最大承载值前需要加上兜底逻辑；
    - 对于已经无货的产品，本地缓存直接返回；
    - 单独部署，减少对系统正常服务的影响，方便扩缩容





